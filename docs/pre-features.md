---
icon: material/pen
---
<!--
hi-lock: (("^!!!.*" (0 "hi-red-b" t)))
hi-lock: (("^\\?\\?\\?.*" (0 "hi-red-b" t)))
hi-lock: end
-->

# プログラミング言語の特徴と分類
<span class="md-tag">教科書2章</span> <span class="md-tag">導入</span>

## プログラミングパラダイム

プログラミングパラダイムとは，プログラミング言語が持つプログラムの規範や哲学のことである．
以下の図は代表的なパラダイムの親子関係である．

```mermaid
graph TD
  パラダイム --> 命令形;
  パラダイム --> 宣言型;
  命令形 -->|ほぼ同義| 手続き型;
  命令形 --> オブジェクト指向;
  宣言型 --> 関数型;
  宣言型 --> 論理型;
```

例えば，FortranやC言語，Pythonは命令型（≒手続き型）のパラダイムに従って設計されている．
命令形では命令（四則演算や比較，代入等）の逐次的な処理によってプログラムを実現する．

```c title="C言語による0～10の加算処理"
int sum = 0;
for (int i = 0; i < 10; i++) {
  sum += i;
}
printf("%d", sum);
```

```py title="Pythonによる0～10の加算処理"
sum = 0
for i in range(11):
    sum += i
print(sum)
```

パラダイムが異なる言語は，その大原則となる規範や哲学が異なるため記法が大幅に変わる．
LispやScalaは関数型パラダイムを採用しており，命令形とは別の考えに従っている．
その大原則は関数適用（application）の繰り返しである．
関数型の詳細については[別の講義回](paradigm-functional.md)で触れる．

```lisp title="Lispによる0～10の加算処理"
(format t "~d"
  (loop for i from 1 to 10 sum i))
```

パラダイムは規範であり厳密な定義はできない．
書籍や文献によって様々な解釈がある点に注意すること．
命令形と手続き型は同一視されることが多い．
命令形と宣言型は基本的に対義関係にある．

!!! note
    音楽のロックというジャンルを厳密に定義できないのと同様である．

世の中には様々なパラダイムが存在している．
新たなプログラミング言語を学ぶ際は，その言語がどのパラダイムを採用しているかを強く意識すること．
    
!!! note
    昨今は複数のパラダイムを採用したマルチパラダイム言語が一般的である．
    各種パラダイムの利点を組み合わせて良い言語を設計している．
    例えばJavaはオブジェクト指向言語であるが，部分的に関数型の機構（ラムダ式やStream API等）を採り入れている．
    
    パラダイムは排他的ではなく共存可能である．

教科書では，計算モデルを共有するプログラミングの枠組みをプログラミングパラダイムと読んでいる．
すなわち「パラダイムの違い＝規範や哲学の違い＝計算モデルの違い」と捉えることができる．
以降では，命令形パラダイムが採用する計算モデル，ノイマン型コンピュータについて説明する．

## ノイマン型コンピュータ
??? info "John von Neumann"
    ![](assets/neumann.gif)
    &copy;[^1]

[^1]: [http://www.lanl.gov/](http://www.lanl.gov/)


プログラムとデータを記憶装置に格納し，順番に読み込んで実行するコンピュータである．
現在のほとんど全てのコンピュータがノイマン型に相当する．
以降ではノイマン型コンピュータを単にコンピュータと呼ぶ．

!!! note
    量子コンピュータは非ノイマン型である．

<!-- 命令形は最初に生まれたパラダイムであり，コンピュータの基本動作と密接に関わっている．-->
コンピュータの基本構成は以下の通りである．単純化のために入出力装置を省略している．

```mermaid
graph LR
    Memory-- load -->CPU
    CPU-- store -->Memory

```

コンピュータの基本動作は以下3ステップである．

1. メモリからデータをCPUへ転送（`load`）
2. 演算の実行（`add`等）
3. 結果をCPUからメモリへ格納（`store`）

[序論で示したアセンブリ](pre-intro.md#_3)の動作と同一である．

```clean title="単純なアセンブリ言語プログラム（再掲）"
load B
add C
store A
```

この`load`→`any process`→`store`の操作を抽象化すると，右辺に式を持つ代入文とみなせる．

```c title="C言語の代入文"
<変数名> = <式>;  // A = B + C;
```

命令型言語はこのような代入文の繰り返しによって，変数の値を動的に変化させ計算を行う点に特徴がある．
まとめると命令型言語は以下の特徴を持つ．

基本要素：
:    変数 ... データと計算結果を保持
:    文　 ... 代入文（`=`）や制御文（`if` `for`）など

特徴：
:    ①代入文の繰り返しで計算を行う
:    ②プログラムは文の並びであり，逐次的に実行する
:    ③代入文によって変数の値を動的に変化させて計算する


!!! note annotate
    この時点で驚きのある内容ではないはず．皆さんのよく知る一般的なプログラミング言語(1)の挙動である．
    
1. CやPython等の命令形パラダイムの言語のこと．


## RAM
ノイマン型コンピュータをさらに単純化した論理的な計算モデル，RAM（random-access machine）を考える．
命令形パラダイムの本質を理解するためである．

!!! note
    ここでのランダムは「任意の」という意味であり「無作為」の意味ではない．
    メモリの任意の場所にアクセスできる機械という意味である．
    順序に従ってのみアクセスできるという，チューリングマシン（TM）のテープと対比するための用語．
    
    現在のメモリはランダムアクセスが可能なため，TMよりもRAMの方が現実に近い．


RAMは1個のレジスタ`c(0)`を持つ．
メモリは複数のメモリセルで構成されており，上から順に`c(1)` `c(2)`...と呼ぶ．
RAMの構成は以下の通りである．(1)
{ .annotate }

1. ここでは入出力テープは省略して考える．

```clean title="RAMの構成"
          
[プログラム]
0000 0000 0001 ◀  // load A
0001 0000 0010    // add B
0010 0000 0011    // store C
 ..   ..   ..  ↑ 
      [プログラムカウンタ]

[記憶装置]
c(0) [ 0 ]  // レジスタ
c(1) [ 2 ]  // メモリ
c(2) [ 5 ]  //  〃
 ..    ..   //  〃
```


プログラム内の機械語命令は演算コードとオペランドの組で構成される．
```clean title="機械語命令の構成"
<演算コード> <オペランド>   // load 1
```

演算コードは次の12個である．(1)
{ .annotate }

1. `read`と`write`は省略．

<!-- for annotate -->

- 転送命令 `load`
- 格納命令 `store`
- 四則演算 `add` `sub` `mult` `div`
- 制御命令 `jump` `jgtz` `jzero`
- 停止命令 `halt`

オペランドには定数，直接アドレス，間接アドレスのいずれかを指定できる．

- `#i` ... 定数`i`を指定
- `i` ... セル`c(i)`を指定（直接アドレス）
- `*i` ... セル`c(c(i))`を指定（間接アドレス）


`load`と`store`に対する具体的なRAMの挙動を示す．
`load`と`store`の主体は常に`c(0)`と考えると良い．

```clean title="load命令に対するRAMの動作例"
命令        挙動            メモリ
-----------------------------------------------------------------
load #1    c(0)←1          c(0) [   ]  // → 1

load 1     c(0)←c(1)       c(0) [   ]  // → 2
                           c(1) [ 2 ]  // この値をc(0)へ転送

load *1    c(0)←c(c(1))    c(0) [   ]  // → 5
                           c(1) [ 2 ]
                           c(2) [ 5 ]  // この値をc(0)へ転送
```

```clean title="store命令に対するRAMの動作例"
命令        挙動            メモリ
-----------------------------------------------------------------
store #1   これはNG

store 1    c(0)→c(1)       c(0) [ 0 ]  // この値をc(1)に格納
                           c(1) [   ]  // → 0

store *1   c(0)→c(c(1))    c(0) [ 0 ]  // この値をc(c(1))に格納
                           c(1) [ 2 ]
                           c(2) [   ]  // → 0
```



機械語命令にはジャンプのためのラベルを付与することもできる．
```clean title="機械語命令の構成"
<ラベル>: <演算コード> <オペランド>   // loop: load 1
```

RAMの機械語プログラムは先頭から逐次的に実行されるが，制御命令（`jump` `jgtz` `jzero`）によって，命令のジャンプが可能である．
例えば`jump loop`は`loop:`ラベルの命令へ制御を移動する．
実際には，プログラムカウンタの値をそのラベルの値に変更することにより，ジャンプを実現している．
<!--無条件ジャンプ`jump`と条件付きジャンプ`jgtz` `jzero`が存在する．-->

| 命令      | 動作                                              |
|-----------|---------------------------------------------------|
| `load a`  | `c(0)` ← `c(a)`                                  |
| `store a` | `c(0)` → `c(a)`                                  |
| `add a`   | `c(0)` ← `c(0) + c(a)`                           |
| `jump b`  | プログラムカウンタ ← `b`                         |
| `jgtz b`  | プログラムカウンタ ← `b`，ただし`c(0) > 0`ならば |
| `jzero b` | プログラムカウンタ ← `b`，ただし`c(0) = 0`ならば |
| `halt`    | 実行終了                                          |

    
以上がRAMの主要構成の説明となる．
続いて，具体的な計算処理を題材にRAMプログラムの挙動を考える．
題材は$\sum\limits_{n=1}^{50} n^2$を出力するプログラムである．



```c title="題材プログラム（C言語）"
main() {
    int sum = 0;
    for (int i = 1; i <= 50; i++) {
        int square = i * i;
        sum += square;
    }
    printf("%d", sum);  // 42925
}
```

上記Cプログラムに対応するRAMプログラムは次の通りである．
各変数とRAM上のメモリセルの対応は以下の通り．

- `c(1)`↔`i`
- `c(2)`↔`square`
- `c(3)`↔`sum`

```clean linenums="1" title="RAMプログラム"
       load   #0      // sum = 0;
       store  3
       load   #1      // i = 1;
       store  1
loop:  load   1       // if (i > 50) goto exit; (1)
       sub    #50
       jgtz   exit
       load   1       // square = i * i;
       mult   1
       store  2
       load   3       // sum += square;
       add    2
       store  3
       load   1       // i++;
       add    #1
       store  1
       jump   loop    // goto loop;
exit:  write  3       // printf("%d", sum);
       halt
```

1. `if (i - 50 > 0)`と解釈．

題材から分かる通り，C言語の文（`i = 0`）はRAMの機械語の数命令（`load` + `store`）に翻訳・コンパイルすることができる．
また，C言語の制御文（`if (i > 50) goto ..`）はRAMの制御命令（`load` + `sub` + `jgtz`）の組み合わせで実現できる．

!!! note
    このコンパイル作業は[3年後期の演習D](https://dev.ics.es.osaka-u.ac.jp/enshud/)で実装することになる．
    今のうちにRAMの基本動作をよく理解しておくこと．

ここで扱ったコンパイル作業は比較的単純な処理である．
これは，C言語や命令型言語そのものの抽象度がそれほど高いものではないことを示唆している．
言い換えれば，命令型言語はコンピュータの基本動作に強く依存して設計されているといえる．

理論的に全てのCプログラムの計算はRAMで模倣可能である．
C言語の計算モデルがRAMであるため，当然といえば当然である．

## まとめ
プログラミング言語が持つ規範や哲学であるプログラミングパラダイムについて説明した．
パラダイムの違いとは，すなわち規範や哲学の違いであり，その言語が採用する計算モデルの違いと捉えることができる．

続いて命令型言語の計算モデルであるノイマン型コンピュータについて説明した．
その特徴は，逐次的な文の実行，及び代入文の繰り返しによって計算を実施する点にある．

最後にノイマン型コンピュータをさらに単純化したRAMを紹介した．
C言語のあらゆる計算処理はRAMで模倣可能である．
